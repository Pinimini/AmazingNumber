type: edu
files:
- name: src/numbers/Main.java
  visible: true
  text: |-
    package numbers;

    import jdk.jshell.execution.JdiExecutionControlProvider;

    import java.util.ArrayList;
    import java.util.List;
    import java.util.Scanner;
    import java.util.stream.Collectors;

    public class Main {
        public static long[] sourceNumberArray = new long[2];
        public static String[] inputArrays;
        public static Number number = new Number();
        public static String key;
        public static Scanner sc = new Scanner(System.in);
        public static long numberForCheck = 0;

        public static void main(String[] args) {

            System.out.println("Welcome to Amazing Numbers!");
            printInstruction();
            inputNumber();

        }

        public static long[] arraysNumber(long[] sourceNumberArray) {
            long[] arraysNumber = new long[(int) sourceNumberArray[1]];
            for (int i = 0; i < sourceNumberArray[1]; i++) {
                arraysNumber[i] = sourceNumberArray[0] + i;
            }
            return arraysNumber;
        }

        public static void inputNumber() {

            while (true) {
                System.out.print("\nEnter a request: ");
                key = sc.nextLine();
                if (key.equals("0")) {
                    System.out.print("\nGoodbye!");
                    System.exit(0);
                }
                numbersToArray(key);
                checkErrors(inputArrays);
                if (key == null) {
                    continue;
                }
                if (inputArrays.length == 1) {
                    number.printProperties(sourceNumberArray[0]);
                } else if (inputArrays.length == 2) {
                    number.printProperties(arraysNumber(sourceNumberArray));
                } else if (inputArrays.length == 3) {
                    number.printProperties(arraysNumberParams(inputArrays[2], sourceNumberArray));
                } else if (inputArrays.length == 4) {
                    number.printProperties(arraysNumberTwoParams(inputArrays[2], inputArrays[3], sourceNumberArray));
                }
            }
        }

        public static void chaneMethodAtParams(String params, long numberForCheck111) {
            switch(params) {
                case "even": number.checkAtEvenNumber(numberForCheck111);
                break;
                case "odd": number.checkAtOddNumber(numberForCheck111);
                break;
                case "buzz": number.checkAtBuzzNumber(numberForCheck111);
                break;
                case "duck": number.checkAtDuckNumber(numberForCheck111);
                    break;
                case "palindromic": number.checkAtPalindromicNumber(numberForCheck111);
                    break;
                case "spy": number.checkAtSpyNumber(numberForCheck111);
                    break;
                case "gapful": number.checkAtGapfulNumber(numberForCheck111);
                    break;
                case "sunny": number.checkAtSunnyNumber(numberForCheck111);
                    break;
                case "square": number.checkAtSquareNumber(numberForCheck111);
                    break;

            }
        }
        public static boolean chaneBooleanMethodAtParams(String params) {
            boolean isParams = false;
            switch(params) {
                case "even": isParams = number.isEven;
                    break;
                case "odd": isParams = number.isOdd;
                    break;
                case "buzz": isParams = number.isBuzz;
                    break;
                case "duck": isParams = number.isDuck;
                    break;
                case "palindromic": isParams = number.isPalindromic;
                    break;
                case "spy": isParams = number.isSpy;
                    break;
                case "gapful": isParams = number.isGapful;
                    break;
                case "sunny": isParams = number.isSunny;
                    break;
                case "square": isParams = number.isSquare;
                    break;
            }
            return isParams;
        }
        public static long[] arraysNumberTwoParams(String params1, String params2,long[] sourceNumberArray) {
            ArrayList<Long> arraysNumberParams = new ArrayList<>();
            numberForCheck = sourceNumberArray[0];
            while (!(arraysNumberParams.size() == (int) sourceNumberArray[1])) {
                number.resetAllProperties();
                chaneMethodAtParams(params1, numberForCheck);
                chaneMethodAtParams(params2, numberForCheck);
                if (chaneBooleanMethodAtParams(params1) && chaneBooleanMethodAtParams(params2)) {
                    arraysNumberParams.add(numberForCheck);
                }
                numberForCheck++;
            }



            long[] arraysNumberParamsReturn = new long[arraysNumberParams.size()];
            for (int i = 0; i < arraysNumberParamsReturn.length; i++) {
                arraysNumberParamsReturn[i] = arraysNumberParams.get(i);
            }
            return arraysNumberParamsReturn;
        }

        private static long[] arraysNumberParams(String params, long[] sourceNumberArray) {
            ArrayList<Long> arraysNumberParams = new ArrayList<>();
            numberForCheck = sourceNumberArray[0];
            switch(params) {
                case "even":

                    while (!(arraysNumberParams.size() == (int) sourceNumberArray[1])) {
                        number.isEven = false;
                        number.checkAtEvenNumber(numberForCheck);
                        if (number.isEven) {
                            arraysNumberParams.add(numberForCheck);
                        }
                        numberForCheck++;
                    }
                    break;
                case "odd":
                    while (!(arraysNumberParams.size() == (int) sourceNumberArray[1])) {
                        number.isOdd = false;
                        number.checkAtOddNumber(numberForCheck);
                        if (number.isOdd) {
                            arraysNumberParams.add(numberForCheck);
                        }
                        numberForCheck++;
                    }
                    break;
                case "buzz":
                    while (!(arraysNumberParams.size() == (int) sourceNumberArray[1])) {
                        number.isBuzz = false;
                        number.checkAtBuzzNumber(numberForCheck);
                        if (number.isBuzz) {
                            arraysNumberParams.add(numberForCheck);
                        }
                        numberForCheck++;
                    }
                    break;
                case "duck":
                    while (!(arraysNumberParams.size() == (int) sourceNumberArray[1])) {
                        number.isDuck = false;
                        number.checkAtDuckNumber(numberForCheck);
                        if (number.isDuck) {
                            arraysNumberParams.add(numberForCheck);
                        }
                        numberForCheck++;
                    }
                    break;
                case "palindromic":
                    while (!(arraysNumberParams.size() == (int) sourceNumberArray[1])) {
                        number.isPalindromic = false;
                        number.checkAtPalindromicNumber(numberForCheck);
                        if (number.isPalindromic) {
                            arraysNumberParams.add(numberForCheck);
                        }
                        numberForCheck++;
                    }
                    break;
                case "spy":
                    while (!(arraysNumberParams.size() == (int) sourceNumberArray[1])) {
                        number.isSpy = false;
                        number.checkAtSpyNumber(numberForCheck);
                        if (number.isSpy) {
                            arraysNumberParams.add(numberForCheck);
                        }
                        numberForCheck++;
                    }
                    break;
                case "gapful":
                    while (!(arraysNumberParams.size() == (int) sourceNumberArray[1])) {
                        number.isGapful = false;
                        number.checkAtGapfulNumber(numberForCheck);
                        if (number.isGapful) {
                            arraysNumberParams.add(numberForCheck);
                        }
                        numberForCheck++;
                    }
                    break;
                case "sunny":
                    while (!(arraysNumberParams.size() == (int) sourceNumberArray[1])) {
                        number.isSunny = false;
                        number.checkAtSunnyNumber(numberForCheck);
                        if (number.isSunny) {
                            arraysNumberParams.add(numberForCheck);
                        }
                        numberForCheck++;
                    }
                    break;
                case "square":
                    while (!(arraysNumberParams.size() == (int) sourceNumberArray[1])) {
                        number.isSquare = false;
                        number.checkAtSquareNumber(numberForCheck);
                        if (number.isSquare) {
                            arraysNumberParams.add(numberForCheck);
                        }
                        numberForCheck++;
                    }
                    break;
            }
            long[] arraysNumberParamsReturn = new long[arraysNumberParams.size()];
            for (int i = 0; i < arraysNumberParamsReturn.length; i++) {
                arraysNumberParamsReturn[i] = arraysNumberParams.get(i);
            }
            return arraysNumberParamsReturn;
        }

        public static void checkErrors(String[] numbersToArray) {
            if (numbersToArray[0].equals("")) {
                printInstruction();
                key = null;
            }
            if (numbersToArray.length == 1) {
                try {
                    sourceNumberArray[0] = Long.parseLong(numbersToArray[0]);
                } catch (Exception e) {
                    System.out.println("\nThe first parameter should be a natural number or zero.");
                    key = null;
                }
                if (sourceNumberArray[0] < 0) {
                    System.out.println("\nThe first parameter should be a natural number or zero.");
                    key = null;
                }
            } else if (numbersToArray.length == 2) {
                try {
                    sourceNumberArray[0] = Long.parseLong(numbersToArray[0]);
                } catch (Exception e) {
                    System.out.println("\nThe first parameter should be a natural number or zero.");
                    key = null;
                }
                try {
                    sourceNumberArray[1] = Long.parseLong(numbersToArray[1]);
                } catch (Exception e) {
                    System.out.println("\nThe second parameter should be a natural number.");
                    key = null;
                }
                if (sourceNumberArray[1] <= 0) {
                    System.out.println("\nThe second parameter should be a natural number.");
                    key = null;
                }
                if (sourceNumberArray[0] <= 0) {
                    System.out.println("\nThe first parameter should be a natural number.");
                    key = null;
                }

            } else if (numbersToArray.length == 3) {
                try {
                    sourceNumberArray[0] = Long.parseLong(numbersToArray[0]);
                } catch (Exception e) {
                    System.out.println("\nThe first parameter should be a natural number or zero.");
                    key = null;
                }
                try {
                    sourceNumberArray[1] = Long.parseLong(numbersToArray[1]);
                } catch (Exception e) {
                    System.out.println("\nThe second parameter should be a natural number.");
                    key = null;
                }
                if (sourceNumberArray[1] <= 0) {
                    System.out.println("\nThe second parameter should be a natural number.");
                    key = null;
                }
                if (sourceNumberArray[0] <= 0) {
                    System.out.println("\nThe first parameter should be a natural number.");
                    key = null;
                }

                if (!numbersToArray[2].toUpperCase().equals("BUZZ")
                        & !numbersToArray[2].toUpperCase().equals("DUCK")
                        & !numbersToArray[2].toUpperCase().equals("GAPFUL")
                        & !numbersToArray[2].toUpperCase().equals("SPY")
                        & !numbersToArray[2].toUpperCase().equals("EVEN")
                        & !numbersToArray[2].toUpperCase().equals("ODD")
                        & !numbersToArray[2].toUpperCase().equals("PALINDROMIC")
                        & !numbersToArray[2].toUpperCase().equals("SUNNY")
                        & !numbersToArray[2].toUpperCase().equals("SQUARE")
                ) {
                    System.out.println("\nThe property [" + key.toUpperCase() + "] is wrong.\n" +
                            "Available properties: [BUZZ, DUCK, PALINDROMIC, GAPFUL, SPY, SQUARE, SUNNY, EVEN, ODD]");
                    key = null;
                }
            } else if (numbersToArray.length == 4) {
                try {
                    sourceNumberArray[0] = Long.parseLong(numbersToArray[0]);
                } catch (Exception e) {
                    System.out.println("\nThe first parameter should be a natural number or zero.");
                    key = null;
                }
                try {
                    sourceNumberArray[1] = Long.parseLong(numbersToArray[1]);
                } catch (Exception e) {
                    System.out.println("\nThe second parameter should be a natural number.");
                    key = null;
                }
                if (sourceNumberArray[1] <= 0) {
                    System.out.println("\nThe second parameter should be a natural number.");
                    key = null;
                }
                if (sourceNumberArray[0] <= 0) {
                    System.out.println("\nThe first parameter should be a natural number.");
                    key = null;
                }
                boolean firstParamWrong = false;
                boolean secondParamWrong = false;
                if (!numbersToArray[2].toUpperCase().equals("BUZZ")
                        & !numbersToArray[2].toUpperCase().equals("DUCK")
                        & !numbersToArray[2].toUpperCase().equals("GAPFUL")
                        & !numbersToArray[2].toUpperCase().equals("SPY")
                        & !numbersToArray[2].toUpperCase().equals("EVEN")
                        & !numbersToArray[2].toUpperCase().equals("ODD")
                        & !numbersToArray[2].toUpperCase().equals("PALINDROMIC")
                        & !numbersToArray[2].toUpperCase().equals("SUNNY")
                        & !numbersToArray[2].toUpperCase().equals("SQUARE")
                ) {
                    firstParamWrong = true;
                }

                if (key != null
                & !numbersToArray[3].toUpperCase().equals("BUZZ")
                        & !numbersToArray[3].toUpperCase().equals("DUCK")
                        & !numbersToArray[3].toUpperCase().equals("GAPFUL")
                        & !numbersToArray[3].toUpperCase().equals("SPY")
                        & !numbersToArray[3].toUpperCase().equals("EVEN")
                        & !numbersToArray[3].toUpperCase().equals("ODD")
                        & !numbersToArray[3].toUpperCase().equals("PALINDROMIC")
                        & !numbersToArray[3].toUpperCase().equals("SUNNY")
                        & !numbersToArray[3].toUpperCase().equals("SQUARE")
                ) {
                    secondParamWrong = true;
                }
                if (firstParamWrong && secondParamWrong) {
                    System.out.println("\nThe properties [" + key.toUpperCase() + "] are wrong.\n" +
                            "Available properties: [BUZZ, DUCK, PALINDROMIC, GAPFUL, SPY, SQUARE, SUNNY, EVEN, ODD]");
                    key = null;
                }
                if (key != null && (firstParamWrong || secondParamWrong)) {
                    System.out.println("\nThe property [" + key.toUpperCase() + "] is wrong.\n" +
                            "Available properties: [BUZZ, DUCK, PALINDROMIC, GAPFUL, SPY, SQUARE, SUNNY, EVEN, ODD]");
                    key = null;
                }
                if (numbersToArray[2].toUpperCase().equals("EVEN") && numbersToArray[3].toUpperCase().equals("ODD")
                        || numbersToArray[2].toUpperCase().equals("DUCK") && numbersToArray[3].toUpperCase().equals("SPY")
                        || numbersToArray[2].toUpperCase().equals("ODD") && numbersToArray[3].toUpperCase().equals("EVEN")
                        || numbersToArray[2].toUpperCase().equals("SPY") && numbersToArray[3].toUpperCase().equals("DUCK")
                        || numbersToArray[2].toUpperCase().equals("SUNNY") && numbersToArray[3].toUpperCase().equals("SQUARE")
                        || numbersToArray[2].toUpperCase().equals("SQUARE") && numbersToArray[3].toUpperCase().equals("SUNNY")
                ) {
                    System.out.println("\nThe request contains mutually exclusive properties: [" + key.toUpperCase() + "]\n" +
                            "There are no numbers with these properties.");
                    key = null;
                }
            }
        }

        public static void numbersToArray(String key) {
            inputArrays = key.split(" ");
        }

        public static void printInstruction() {
            System.out.println(
                    "\nSupported requests:\n" +
                            "- enter a natural number to know its properties; \n" +
                            "- enter two natural numbers to obtain the properties of the list:\n" +
                            "  * the first parameter represents a starting number;\n" +
                            "  * the second parameter shows how many consecutive numbers are to be printed;\n" +
                            "- two natural numbers and a property to search for;\n" +
                            "- two natural numbers and two properties to search for;\n" +
                            "- separate the parameters with one space;\n" +
                            "- enter 0 to exit.");
        }
    }
  learner_created: false
- name: src/numbers/Number.java
  visible: true
  text: |
    package numbers;

    import java.util.ArrayList;

    public class Number {
        boolean isEven;
        boolean isOdd;
        boolean isBuzz;
        boolean isDuck;
        boolean isPalindromic;
        boolean isGapful;
        boolean isSpy;
        boolean isSunny;
        boolean isSquare;



        public void checkNumberAllProperties(long number) {
            checkAtEvenNumber(number);
            checkAtOddNumber(number);
            checkAtBuzzNumber(number);
            checkAtDuckNumber(number);
            checkAtPalindromicNumber(number);
            checkAtGapfulNumber(number);
            checkAtSpyNumber(number);
            checkAtSunnyNumber(number);
            checkAtSquareNumber(number);
        }
        public void resetAllProperties() {
            isOdd = false;
            isEven = false;
            isBuzz = false;
            isDuck = false;
            isPalindromic = false;
            isGapful = false;
            isSpy = false;
            isSunny = false;
            isSquare = false;
        }
        public void printProperties(long number) {
            checkNumberAllProperties(number);
            System.out.println("\nProperties of " + number +
                    "\neven: " + isEven +
                    "\nodd: " + isOdd +
                    "\nbuzz: " + isBuzz +
                    "\nduck: " + isDuck +
                    "\npalindromic: " + isPalindromic +
                    "\ngapful: " + isGapful +
                    "\nsunny: " + isSunny +
                    "\nsquare: " + isSquare +
                    "\nspy: " + isSpy);
            resetAllProperties();
        }

        public void printProperties(long[] sourceNumberArray) {
            System.out.println();
            for (int i = 0; i < sourceNumberArray.length; i++) {
                checkNumberAllProperties(sourceNumberArray[i]);
                String isBuzz1 = isBuzz ? "buzz, " : "";
                String isDuck1 = isDuck ? "duck, " : "";
                String isPalindromic1 = isPalindromic ? "palindromic, " : "";
                String isGapful1 = isGapful ? "gapful, " : "";
                String isSpy1 = isSpy ? "spy, " : "";
                String isSunny1 = isSunny ? "sunny, " : "";
                String isSquare1 = isSquare ? "square, " : "";
                String isOdd1 = isOdd ? "odd" : "";
                String isEven1 = isEven ? "even" : "";
                System.out.println(sourceNumberArray[i] + " is " + isBuzz1 + isDuck1 + isSquare1 + isSunny1 + isPalindromic1 + isGapful1 + isSpy1 + isOdd1 + isEven1);
                resetAllProperties();
            }
        }

        public ArrayList<String> stringPropertiesArrays(long[] sourceNumberArray) {
            ArrayList<String> stringsPropertiesArrays = new ArrayList<>();
            for (int i = 0; i < sourceNumberArray.length; i++) {
                checkNumberAllProperties(sourceNumberArray[i]);
                String isBuzz1 = isBuzz ? "buzz, " : "";
                String isDuck1 = isDuck ? "duck, " : "";
                String isPalindromic1 = isPalindromic ? "palindromic, " : "";
                String isGapful1 = isGapful ? "gapful, " : "";
                String isSpy1 = isSpy ? "spy, " : "";
                String isSunny1 = isSunny ? "sunny, " : "";
                String isSquare1 = isSquare ? "square, " : "";
                String isOdd1 = isOdd ? "odd" : "";
                String isEven1 = isEven ? "even" : "";
                stringsPropertiesArrays.add(sourceNumberArray[i] + " is " + isBuzz1 + isDuck1 + isSquare1 + isSunny1 + isPalindromic1 + isGapful1 + isSpy1 + isOdd1 + isEven1);
                resetAllProperties();
            }
            return stringsPropertiesArrays;
        }

        // Проверки на свойства числа
        public void checkAtEvenNumber(long number) {
            if (number % 2 == 0) {
                isEven = true;
            }
        }

        public void checkAtOddNumber(long number) {
            if (number % 2 != 0) {
                isOdd = true;
            }
        }

        public void checkAtBuzzNumber(long number) {
            String numberString = number + "";
            String lastCharNumberString = numberString.substring(numberString.length() - 1);
            if (number % 7 == 0 || lastCharNumberString.equals("7")) {
                isBuzz = true;
            }
        }

        public void checkAtDuckNumber(long number) {
            String numberString = number + "";
            String withoutFirstChar = numberString.substring(1);
            if (withoutFirstChar.contains("0")) {
                isDuck = true;
            }
        }

        public void checkAtPalindromicNumber(long number) {
            String numberString = number + "";
            for (int i = 0; i < numberString.length(); i++) {
                if (numberString.charAt(i) == numberString.charAt(numberString.length() - 1 - i)) {
                    isPalindromic = true;
                } else {
                    isPalindromic = false;
                    break;
                }
            }
        }

        public void checkAtGapfulNumber(long number) {
            String numberString = number + "";
            String firstAndLastChar = String.valueOf(numberString.charAt(0)) + String.valueOf(numberString.charAt(numberString.length() - 1));
            int firstAndLastCharInt = Integer.parseInt(firstAndLastChar);
            if (numberString.length() >= 3 && number % (long) firstAndLastCharInt == 0) {
                isGapful = true;
            }
        }

        public void checkAtSpyNumber(long number) {
            String numberString = number + "";
            long sumNumbers = 0;
            long productNumbers = 1;
            for (int i = 0; i < numberString.length(); i++) {
                sumNumbers += Integer.parseInt(numberString.charAt(i) + "");
                productNumbers *= Integer.parseInt(numberString.charAt(i) + "");
            }
            if (sumNumbers == productNumbers) {
                isSpy = true;
            }
        }

        public void checkAtSunnyNumber(long number) {
            double numberSqrt = Math.sqrt(number + 1);
            if (numberSqrt % 1 == 0) {
                isSunny = true;
            }
        }

        public void checkAtSquareNumber(long number) {
            double numberSqrt = Math.sqrt(number);
            if (numberSqrt % 1 == 0) {
                isSquare = true;
            }
        }
    }
  learner_created: false
- name: test/util/Checker.java
  visible: false
  text: |
    package util;

    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;

    import java.text.MessageFormat;
    import java.util.function.Predicate;
    import java.util.function.UnaryOperator;

    import static java.util.Objects.isNull;

    public class Checker implements UnaryOperator<UserProgram> {
        protected Predicate<UserProgram> validator;
        protected String feedback;
        protected Object[] parameters;

        protected Checker() {
            this("Incorrect output for user input: {0}.");
        }

        protected Checker(String feedback) {
            this($ -> true, feedback);
        }

        public Checker(Predicate<UserProgram> validator, String feedback) {
            this.feedback = feedback;
            this.validator = validator;
        }

        @Override
        public UserProgram apply(UserProgram program) {
            if (validator.test(program)) {
                return program;
            }
            throw new WrongAnswer(MessageFormat.format(feedback, isNull(parameters)
                    ? new Object[]{program.getInput(), program.getOutput()} : parameters));

        }

    }
  learner_created: false
- name: test/util/TextChecker.java
  visible: false
  text: |
    package util;

    public class TextChecker extends Checker {

        public TextChecker(String expected) {
            this(expected, "Expected that the output contains \"{2}\".");
        }

        public TextChecker(String expected, String feedback) {
            super(feedback);

            validator = program -> {
                parameters = new Object[]{program.getInput(), program.getOutput(), expected};
                return program.getOutput().toLowerCase().contains(expected.toLowerCase());
            };
        }

    }
  learner_created: false
- name: test/util/UserProgram.java
  visible: false
  text: |-
    package util;

    import org.hyperskill.hstest.testcase.CheckResult;
    import org.hyperskill.hstest.testing.TestedProgram;

    import java.util.function.Function;

    public class UserProgram {
        private TestedProgram program;

        private Object input;
        private String output;

        public UserProgram start(String... args) {
            program = new TestedProgram();
            output = program.start(args);
            return this;
        }

        public UserProgram check(final Function<UserProgram, UserProgram> checker) {
            return checker.apply(this);
        }

        public CheckResult result() {
            return CheckResult.correct();
        }

        public UserProgram execute(Object userInput) {
            this.input = userInput;
            output = program.execute(userInput.toString());
            return this;
        }

        public String getOutput() {
            return output;
        }

        public Object getInput() {
            return input;
        }

        public boolean isFinished() {
            return program.isFinished();
        }
    }
  learner_created: false
- name: test/util/LinesChecker.java
  visible: false
  text: |
    package util;

    import static java.util.function.Predicate.not;

    public class LinesChecker extends Checker {

        public LinesChecker(final long expected) {
            super("Expected {0} non blank lines but actual output contains {1} lines.");

            validator = program -> {
                final var actual = program.getOutput().lines().filter(not(String::isBlank)).count();
                parameters = new Object[]{expected, actual};
                return actual == expected;
            };
        }


    }
  learner_created: false
- name: test/util/RegexChecker.java
  visible: false
  text: |
    package util;

    import java.util.regex.Pattern;

    public class RegexChecker extends Checker {
        private final Pattern expected;

        public RegexChecker(final String regexp, final String feedback) {
            this(regexp, Pattern.CASE_INSENSITIVE, feedback);
        }

        public RegexChecker(final String regexp, final int flags, final String feedback) {
            super(feedback);
            this.expected = Pattern.compile(regexp, flags);
            validator = program -> expected.matcher(program.getOutput()).find();
        }

    }
  learner_created: false
- name: test/Request.java
  visible: false
  text: |
    import util.LinesChecker;

    import java.util.Random;
    import java.util.regex.Pattern;

    public class Request {
        public static final Pattern PARAMETERS_SEPARATOR = Pattern.compile("\\s+");
        public static final int MAX_COUNT = 20;
        private static final Random random = new Random();

        private final String request;
        private final long start;
        private final int count;
        private String[] properties;

        public Request(String request) {
            this.request = request;
            var data = PARAMETERS_SEPARATOR.split(request, 3);
            int type = data.length;
            properties = type == 3 ? PARAMETERS_SEPARATOR.split(data[2]) : new String[0];
            count = type > 1 ? Integer.parseInt(data[1]) : 0;
            start = Long.parseLong(data[0]);
        }

        public static Request random(Parameter params) {
            final var start = 1 + random.nextInt(Short.MAX_VALUE);
            if (params == Parameter.ONE) {
                return new Request(String.valueOf(start));
            }
            final var count = 1 + random.nextInt(MAX_COUNT);
            if (params == Parameter.TWO) {
                return new Request(start + " " + count);
            }
            final var index = random.nextInt(NumberProperty.values().length);
            final var property = NumberProperty.values()[index].name();
            final var request = start + " " + count + " " + property;
            return new Request(request);
        }

        public long getStart() {
            return start;
        }

        public int getCount() {
            return count;
        }

        public String[] getProperties() {
            return properties;
        }

        public LinesChecker getLinesChecker() {
            return new LinesChecker(count + 1);
        }

        @Override
        public String toString() {
            return request;
        }

        enum Parameter {ONE, TWO, THREE}
    }
  learner_created: false
- name: test/ListChecker.java
  visible: false
  text: |
    import util.Checker;
    import util.UserProgram;

    import java.util.Arrays;
    import java.util.Set;
    import java.util.function.LongPredicate;
    import java.util.function.Predicate;
    import java.util.regex.Pattern;
    import java.util.stream.Collectors;
    import java.util.stream.LongStream;

    public class ListChecker extends Checker {
        private static final Pattern LINE_PATTERN = Pattern.compile(
                "\\s*(?<number>[\\d,. ]*\\d)\\s*(is|:|-)\\s*(?<properties>.+)",
                Pattern.CASE_INSENSITIVE);
        private static final Pattern NON_DIGIT_SYMBOL = Pattern.compile("\\D");
        private static final Pattern PROPERTIES_SEPARATOR = Pattern.compile("[, ;]+");

        private final long expectedCount;
        private final long[] expectedList;

        public ListChecker(Request request) {
            this(request.getStart(), request.getCount(), request.getProperties());
        }

        public ListChecker(long start, long count) {
            this(start, count, new String[0]);
        }

        public ListChecker(long start, long count, String properties) {
            this(start, count, properties.split("[, ]+"));
        }

        public ListChecker(long start, long count, String[] queries) {
            super("The list is incorrect");
            this.validator = this::test;
            this.expectedList = getExpectedList(start, count, queries);
            this.expectedCount = count;
        }

        private static long[] getExpectedList(long start, long count, String[] queries) {
            final var condition = Arrays.stream(queries).map(query -> {
                final var isNegative = query.startsWith("-");
                final var name = isNegative ? query.substring(1) : query;
                final var property = NumberProperty.valueOf(name.toUpperCase());
                return isNegative ? property.negate() : property;
            }).reduce(number -> true, LongPredicate::and);

            return LongStream
                    .iterate(start, n -> n > 0, n -> n + 1)
                    .filter(condition).limit(count).toArray();
        }

        public boolean test(UserProgram program) {
            final var lines = program.getOutput()
                    .lines()
                    .filter(Predicate.not(String::isBlank))
                    .limit(expectedCount)
                    .collect(Collectors.toUnmodifiableList());

            if (lines.size() != expectedCount) {
                return false;
            }

            final var iterator = lines.iterator();
            for (final long expectedNumber : expectedList) {
                final var actualLine = iterator.next();
                final var matcher = LINE_PATTERN.matcher(actualLine);
                if (!matcher.matches()) {
                    feedback = "Can''t parse line: \"{0}\". Expected: {1} is ...";
                    parameters = new Object[]{actualLine, expectedNumber};
                    return false;
                }

                final var rawNumber = matcher.group("number").strip();
                final var actualNumber = NON_DIGIT_SYMBOL.matcher(rawNumber).replaceAll("");

                if (!String.valueOf(expectedNumber).equals(actualNumber)) {
                    feedback = "Expected number is {0} but actual number is {1}.";
                    parameters = new Object[]{expectedNumber, rawNumber};
                    return false;
                }

                final var actualProperties = PROPERTIES_SEPARATOR
                        .splitAsStream(matcher.group("properties").toLowerCase())
                        .collect(Collectors.toUnmodifiableList());

                final var expectedProperties = Arrays
                        .stream(NumberProperty.values())
                        .filter(property -> property.test(expectedNumber))
                        .map(Enum::name)
                        .map(String::toLowerCase)
                        .collect(Collectors.toUnmodifiableSet());

                if (actualProperties.size() != expectedProperties.size()) {
                    feedback = "For the number {0} the expected number of properties is {1} but the actual number of properties is {2}. " +
                            "Expected properties are {3}. Actual properties are {4}";
                    parameters = new Object[]{expectedNumber, expectedProperties.size(),
                            actualProperties.size(), expectedProperties, actualProperties};
                    return false;
                }

                if (!Set.copyOf(actualProperties).equals(expectedProperties)) {
                    feedback = "For the number {0} the expected properties are {1}. The actual properties are {2}.";
                    parameters = new Object[]{expectedNumber, expectedProperties, actualProperties};
                }
            }
            return true;
        }
    }
  learner_created: false
- name: test/NumbersTest.java
  visible: false
  text: |
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.stage.StageTest;
    import org.hyperskill.hstest.testcase.CheckResult;
    import util.*;

    import java.util.Arrays;
    import java.util.Random;
    import java.util.function.Function;
    import java.util.function.Predicate;
    import java.util.regex.Matcher;
    import java.util.regex.Pattern;
    import java.util.stream.LongStream;
    import java.util.stream.Stream;

    public final class NumbersTest extends StageTest {
        private static final Random random = new Random();

        private static final int NEGATIVE_NUMBERS_TESTS = 5;
        private static final int FIRST_NUMBERS = 15;
        private static final int RANDOM_TESTS = 10;
        private static final int MAX_PROPERTIES = 5;
        private static final int MAX_COUNT = 20;
        private static final int MIN_START = 2;

        private static final Checker WELCOME = new TextChecker("Welcome to Amazing Numbers!");

        private static final String EXPLAIN = "The program should explain this in the help.";
        private static final Function<UserProgram, UserProgram> HELP =
                new TextChecker("Supported requests")
                        .andThen(new RegexChecker(
                                "(one|a) natural number",
                                "In this stage, a user can enter one number to print a card. " + EXPLAIN))
                        .andThen(new TextChecker(
                                "two natural numbers",
                                "In this stage, a user can enter two numbers to print a list. " + EXPLAIN))
                        .andThen(new TextChecker(
                                "properties to search for",
                                "In this stage, a user can enter two numbers and properties to search for. "
                                        + EXPLAIN))
                        .andThen(new TextChecker(
                                "property preceded by minus",
                                "In this stage, a user can a minus in front of the property. "
                                        + EXPLAIN))
                        .andThen(new TextChecker(
                                "enter 0 to exit",
                                "Display the instructions on how to exit"));

        private static final Checker ASK_REQUEST = new TextChecker(
                "enter a request",
                "The program should ask a user to enter a request."
        );
        private static final Checker ERROR_FIRST = new RegexChecker(
                "The first (parameter|number) should be a natural number or zero",
                "The first parameter \"{0}\" is wrong. The program should print an error message."
        );
        private static final Checker ERROR_SECOND = new RegexChecker(
                "The second (parameter|number) should be a natural number",
                "The second parameter \"{0}\" is wrong. The program should print an error message."
        );
        private static final Checker ERROR_PROPERTY = new RegexChecker(
                "The property .+ is wrong",
                "The request: \"{0}\" has one wrong property. "
                        + "Expected message: \"The property ... is wrong\"."
        );
        private static final Checker ERROR_PROPERTIES = new RegexChecker(
                "The properties .+ are wrong",
                "The request: \"{0}\" has two or more incorrect properties. "
                        + "Expected that error message contains: \"The properties ... are wrong\"."
        );
        private static final Checker HELP_PROPERTIES = new TextChecker(
                "Available properties"
        );
        private static final Checker LIST_PROPERTIES = new Checker(
                program -> Arrays.stream(NumberProperty.values())
                        .map(Enum::name)
                        .map("(?i)\\b"::concat)
                        .map(Pattern::compile)
                        .map(p -> p.matcher(program.getOutput()))
                        .allMatch(Matcher::find),
                "If incorrect property has been specified, show the list of the available properties."
        );
        private static final Checker PROPERTIES_OF = new RegexChecker(
                "properties of \\d",
                "The first line of number''s properties should contain \"Properties of {0}\"."
        );
        private static final Checker MUTUALLY_EXCLUSIVE = new TextChecker(
                "The request contains mutually exclusive properties",
                "The request contains mutually exclusive properties. "
                        + "The program should cancel the request and warn the user."
        );
        private static final Checker RUNNING = new Checker(Predicate.not(UserProgram::isFinished),
                "The program should continue to work till the user enter \"0\"."
        );
        private static final Checker FINISHED = new Checker(UserProgram::isFinished,
                "The program should finish when the user entered \"0\"."
        );
        private final UserProgram program = new UserProgram();

        private final String[] wrongProperty = new String[]{
                "1 10 May", "40 2 bay", "37 4 8", "67 2 day", "2 54 Prime", "6 8 ...", "5 9 none"
        };
        private final String[] wrongSecondProperty = new String[]{
                "1 10 odd girl", "40 2 even day", "37 4 spy 89", "67 2 DUCK +"
        };
        private final String[] wrongTwoProperties = new String[]{
                "1 10 boy friend", "40 2 long day", "37 4 hot girl", "67 2 strong drake"
        };
        private static final String[] ONE_PROPERTY_WRONG = new String[]{
                "26534 3 buzz evens palindromic",
                "4384 2 odd -buzz -palindromic shiny gapful",
                "1 7 hot sunny odd odd -even",
                "78343 4 sunny -duck mac odd",
                "3 4 -even -sunny -hot"
        };
        private final String[] mutuallyExclusive = new String[]{
                // Stage #6 Two properties
                "5 1 odd even", "4 3 even odd", "32 2 sunny square", "3153 2 spy duck", "6 7 duck spy",
                // Stage #7 Several properties
                "1 2 spy odd sunny even", "7 2 sunny even duck buzz square", "9 5 even spy buzz duck",
                // Stage #8 Properties preceded by minus
                "6 6 -odd -even", "6 7 odd -odd", "8 1 -even even", "3 5 odd duck buzz -duck sunny"
        };
        // Stage #3

        @DynamicTest(order = 5)
        CheckResult welcomeTest() {
            return program
                    .start()
                    .check(WELCOME)
                    .check(HELP)
                    .check(RUNNING)
                    .check(ASK_REQUEST)
                    .execute(0)
                    .check(FINISHED)
                    .result();
        }

        @DynamicTest(repeat = NEGATIVE_NUMBERS_TESTS, order = 10)
        CheckResult notNaturalNumbersTest() {
            long negativeNumber = -random.nextInt(Byte.MAX_VALUE) - 1L;
            return program
                    .start()
                    .check(WELCOME)
                    .check(HELP)
                    .check(ASK_REQUEST)
                    .execute(negativeNumber)
                    .check(ERROR_FIRST)
                    .check(RUNNING)
                    .check(ASK_REQUEST)
                    .execute(0)
                    .check(FINISHED)
                    .result();
        }

        @DynamicTest(repeat = RANDOM_TESTS, order = 15)
        CheckResult notNaturalSecondNumberTest() {
            int first = 1 + random.nextInt(Short.MAX_VALUE);
            int negativeSecond = -random.nextInt(Short.MAX_VALUE);
            return program
                    .start()
                    .check(WELCOME)
                    .check(HELP)
                    .check(ASK_REQUEST)
                    .execute(first + " " + negativeSecond)
                    .check(ERROR_SECOND)
                    .check(RUNNING)
                    .check(ASK_REQUEST)
                    .execute(0)
                    .check(FINISHED)
                    .result();
        }

        // Stage #4

        @DynamicTest(order = 20)
        CheckResult naturalNumbersTest() {
            final var numbers = LongStream.concat(
                    LongStream.range(1, FIRST_NUMBERS),
                    random.longs(RANDOM_TESTS, 1, Long.MAX_VALUE)
            );

            program.start().check(WELCOME).check(HELP);

            numbers.forEach(number -> program
                    .check(ASK_REQUEST)
                    .execute(number)
                    .check(PROPERTIES_OF)
                    .check(new PropertiesChecker(number))
                    .check(RUNNING));

            return program
                    .check(RUNNING)
                    .check(ASK_REQUEST)
                    .execute(0)
                    .check(FINISHED)
                    .result();
        }

        @DynamicTest(order = 40)
        CheckResult firstNumbersListTest() {
            return program
                    .start()
                    .check(WELCOME)
                    .check(HELP)
                    .check(ASK_REQUEST)
                    .execute("1 " + FIRST_NUMBERS)
                    .check(new LinesChecker(FIRST_NUMBERS + 1))
                    .check(new ListChecker(1, FIRST_NUMBERS))
                    .execute(0)
                    .check(FINISHED)
                    .result();
        }

        private Object[][] getRandomTwo() {
            return random
                    .longs(RANDOM_TESTS, MIN_START, Long.MAX_VALUE - MAX_COUNT)
                    .mapToObj(start -> new Long[]{start, (long) 1 + random.nextInt(MAX_COUNT)})
                    .toArray(Long[][]::new);
        }

        // Stage #5

        @DynamicTest(data = "getRandomTwo", order = 44)
        CheckResult twoRandomNumbersTest(long start, long count) {
            return program
                    .start()
                    .check(WELCOME)
                    .check(HELP)
                    .check(ASK_REQUEST)
                    .execute(start + " " + count)
                    .check(new LinesChecker(count + 1))
                    .check(new ListChecker(start, count))
                    .check(RUNNING)
                    .execute(0)
                    .check(FINISHED)
                    .result();
        }

        @DynamicTest(data = "wrongProperty", order = 50)
        CheckResult wrongPropertyRequestTest(String wrongProperty) {
            return program
                    .start()
                    .check(WELCOME)
                    .check(HELP)
                    .check(ASK_REQUEST)
                    .execute(wrongProperty)
                    .check(ERROR_PROPERTY)
                    .check(HELP_PROPERTIES)
                    .check(LIST_PROPERTIES)
                    .check(RUNNING)
                    .check(ASK_REQUEST)
                    .execute(0)
                    .check(FINISHED)
                    .result();
        }

        // The test generates and checks request "1 10 <property>" for each property

        @DynamicTest(order = 53)
        CheckResult allPropertiesTest() {
            program.start().check(WELCOME).check(HELP);

            Arrays.stream(NumberProperty.values())
                    .map(Enum::name)
                    .map("1 10 "::concat)
                    .map(Request::new)
                    .peek(program.check(ASK_REQUEST)::execute)
                    .forEach(request -> program
                            .check(request.getLinesChecker())
                            .check(new ListChecker(request))
                            .check(RUNNING)
                    );

            return program.execute(0).check(FINISHED).result();
        }

        // Stage #6

        @DynamicTest(repeat = RANDOM_TESTS, order = 55)
        CheckResult randomTwoNumbersAndPropertyTest() {
            final var request = Request.random(Request.Parameter.THREE);
            return program
                    .start()
                    .check(WELCOME)
                    .check(HELP)
                    .check(ASK_REQUEST)
                    .execute(request)
                    .check(request.getLinesChecker())
                    .check(new ListChecker(request))
                    .check(RUNNING)
                    .check(ASK_REQUEST)
                    .execute(0)
                    .check(FINISHED)
                    .result();
        }

        @DynamicTest(data = "wrongSecondProperty", order = 60)
        CheckResult wrongSecondPropertyRequestTest(String wrongSecondProperty) {
            return program
                    .start()
                    .check(WELCOME)
                    .check(HELP)
                    .check(ASK_REQUEST)
                    .execute(wrongSecondProperty)
                    .check(ERROR_PROPERTY)
                    .check(HELP_PROPERTIES)
                    .check(LIST_PROPERTIES)
                    .check(RUNNING)
                    .check(ASK_REQUEST)
                    .execute(0)
                    .check(FINISHED)
                    .result();
        }

        @DynamicTest(data = "wrongTwoProperties", order = 62)
        CheckResult wrongTwoPropertiesRequestTest(String wrongTwoProperties) {
            return program
                    .start()
                    .check(WELCOME)
                    .check(HELP)
                    .check(ASK_REQUEST)
                    .execute(wrongTwoProperties)
                    .check(ERROR_PROPERTIES)
                    .check(HELP_PROPERTIES)
                    .check(LIST_PROPERTIES)
                    .check(RUNNING)
                    .check(ASK_REQUEST)
                    .execute(0)
                    .check(FINISHED)
                    .result();
        }

        private Request[] searchTwoProperties() {
            return Stream.of(
                    "1 7 even spy",
                    "1 10 odd buzz",
                    "1 9 buzz gapful",
                    "1 10 spy buzz",
                    "100000 2 even spy",
                    "100 4 odd gapful",
                    "2000 4 palindromic duck")
                    .map(Request::new)
                    .toArray(Request[]::new);
        }

        @DynamicTest(data = "searchTwoProperties", order = 65)
        CheckResult twoNumbersAndTwoPropertyTest(Request request) {
            return program
                    .start()
                    .check(WELCOME)
                    .check(HELP)
                    .check(ASK_REQUEST)
                    .execute(request)
                    .check(request.getLinesChecker())
                    .check(new ListChecker(request))
                    .check(RUNNING)
                    .check(ASK_REQUEST)
                    .execute(0)
                    .check(FINISHED)
                    .result();
        }

        // Stage #7

        @DynamicTest(data = "ONE_PROPERTY_WRONG", order = 72)
        CheckResult oneWrongPropertyTest(String request) {
            return program
                    .start()
                    .check(WELCOME)
                    .check(HELP)
                    .check(ASK_REQUEST)
                    .execute(request)
                    .check(ERROR_PROPERTY)
                    .check(HELP_PROPERTIES)
                    .check(LIST_PROPERTIES)
                    .check(RUNNING)
                    .check(ASK_REQUEST)
                    .execute(0)
                    .check(FINISHED)
                    .result();
        }

        private Request[] getRandomRequests() {
            return Stream.of(
                    "1 7 odd spy palindromic",
                    "1 10 even palindromic duck buzz",
                    "1 9 even palindromic duck buzz gapful",
                    "1 10 even sunny duck buzz gapful",
                    "100000 2 even spy buzz gapful",
                    "100 4 odd spy gapful",
                    "2000 4 even palindromic duck",
                    // Stage #8
                    "1 15 odd spy -duck spy buzz",
                    "1 2 jumping happy -spy"
            )
                    .map(Request::new)
                    .toArray(Request[]::new);
        }

        @DynamicTest(data = "getRandomRequests", order = 75)
        CheckResult manyPropertiesTest(Request request) {
            return program
                    .start()
                    .check(WELCOME)
                    .check(HELP)
                    .check(ASK_REQUEST)
                    .execute(request)
                    .check(request.getLinesChecker())
                    .check(new ListChecker(request))
                    .check(RUNNING)
                    .check(ASK_REQUEST)
                    .execute(0)
                    .check(FINISHED)
                    .result();
        }

        // Stage #8 If a property is preceded by a minus, this property should not be present in a number

        @DynamicTest(data = "mutuallyExclusive", order = 80)
        CheckResult mutuallyExclusivePropertiesTest(String mutuallyExclusive) {
            return program
                    .start()
                    .check(WELCOME)
                    .check(HELP)
                    .check(ASK_REQUEST)
                    .execute(mutuallyExclusive)
                    .check(MUTUALLY_EXCLUSIVE)
                    .check(RUNNING)
                    .check(ASK_REQUEST)
                    .execute(0)
                    .check(FINISHED)
                    .result();
        }

        // The test generates and checks request "1 15 -PROPERTY" for all properties

        @DynamicTest(order = 85)
        CheckResult allMinusPropertiesTest() {
            program.start().check(WELCOME).check(HELP);

            Arrays.stream(NumberProperty.values())
                    .map(Enum::name)
                    .map("1 15 -"::concat)
                    .map(Request::new)
                    .peek(program.check(ASK_REQUEST)::execute)
                    .forEach(request -> program
                            .check(request.getLinesChecker())
                            .check(new ListChecker(request))
                            .check(RUNNING)
                    );

            return program.execute(0).check(FINISHED).result();
        }

    }
  learner_created: false
- name: test/NumberProperty.java
  visible: false
  text: |
    import java.util.Optional;
    import java.util.function.LongPredicate;
    import java.util.regex.Pattern;
    import java.util.stream.LongStream;

    import static java.lang.Character.getNumericValue;

    public enum NumberProperty implements LongPredicate {
        EVEN(x -> x % 2 == 0),
        ODD(x -> x % 2 != 0),
        BUZZ(x -> x % 7 == 0 || x % 10 == 7),
        DUCK(number -> digits(number).anyMatch(digit -> digit == 0)),
        PALINDROMIC(number -> {
            final var digits = String.valueOf(number);
            return new StringBuilder(digits).reverse().toString().equals(digits);
        }),
        GAPFUL(number -> number >= 100 &&
                number % (getNumericValue(String.valueOf(number).charAt(0)) * 10L + number % 10) == 0),
        SPY(x -> digits(x).sum() == digits(x).reduce(1L, (a, b) -> a * b)),
        SQUARE(number -> Math.sqrt(number) % 1 == 0),
        SUNNY(number -> Math.sqrt(number + 1) % 1 == 0),
        JUMPING(number -> {
            for (long previous = number % 10, rest = number / 10; rest > 0; rest /= 10) {
                long current = rest % 10;
                long delta = previous - current;
                if (delta * delta != 1) {
                    return false;
                }
                previous = current;
            }
            return true;
        }),
        HAPPY(number -> LongStream.iterate(number, i -> i > 1, NumberProperty::nextHappy).noneMatch(i -> i == 4)),
        SAD(number -> !HAPPY.test(number));

        private final LongPredicate hasProperty;
        private final Pattern pattern = Pattern.compile(
                name() + "\\s*[:-]\\s*(?<value>true|false)",
                Pattern.CASE_INSENSITIVE
        );

        NumberProperty(LongPredicate hasProperty) {
            this.hasProperty = hasProperty;
        }

        private static LongStream digits(long number) {
            return Long.toString(number).chars().mapToLong(Character::getNumericValue);
        }

        @Override
        public boolean test(long number) {
            return hasProperty.test(number);
        }

        public Optional<Boolean> extractValue(String output) {
            final var matcher = pattern.matcher(output);
            final var isFound = matcher.find();
            return Optional
                    .ofNullable(isFound ? matcher.group("value") : null)
                    .map(Boolean::valueOf);
        }

        private static long nextHappy(long number) {
            long result = 0;
            for (long i = number; i > 0; i /= 10) {
                long digit = i % 10;
                result += digit * digit;
            }
            return result;
        }
    }
  learner_created: false
- name: test/PropertiesChecker.java
  visible: false
  text: |
    import util.Checker;
    import util.UserProgram;

    public class PropertiesChecker extends Checker {
        private final long number;

        public PropertiesChecker(long number) {
            this.number = number;
            validator = this::test;
        }

        public boolean test(UserProgram program) {
            for (var property : NumberProperty.values()) {
                final var name = property.name();

                if (!program.getOutput().toLowerCase().contains(name.toLowerCase())) {
                    feedback = "The property \"{0}\" was not found in the output.";
                    parameters = new Object[]{name};
                    return false;
                }

                final var expected = property.test(number);
                final var actualValue = property.extractValue(program.getOutput());

                if (actualValue.isEmpty()) {
                    feedback = "The value for property {0} was not found. Expected: {1}";
                    parameters = new Object[]{name, expected};
                    return false;
                }
                final var actual = actualValue.get();

                if (expected != actual) {
                    feedback = "For the property {0}, the expected value is {1} but was found {2}.";
                    parameters = new Object[]{name, expected, actual};
                    return false;
                }
            }
            return true;
        }
    }
  learner_created: false
- name: src/numbers/InvalidParamException.java
  visible: true
  text: |
    package numbers;

    public class InvalidParamException extends Exception {
        private int param;

        public InvalidParamException(int param) {
            this.param = param;
        }

        public int getParam() {
            return param;
        }
    }
  learner_created: true
- name: src/numbers/SeveralNumbers.java
  visible: true
  text: |-
    package numbers;

    import java.util.ArrayList;
    import java.util.Arrays;

    public class SeveralNumbers extends Number {

        public SeveralNumbers(String value) {
            super(value);
        }

        public static ArrayList<SeveralNumbers> createArrayNumbers(String input) {
            ArrayList<SeveralNumbers> numbersList = new ArrayList<>();
            String[] inputData = input.split(" ");
            long firstNumber = Long.parseLong(inputData[0]);
            int amountOfNumber = Integer.parseInt(inputData[1]);
            for (int i = 0; i < amountOfNumber; i++) {
                numbersList.add(new SeveralNumbers(String.valueOf(firstNumber + i)));
            }
            return numbersList;
        }

        public static ArrayList<SeveralNumbers> createArrayNumbersForProperties(String input) {
            String[] inputData = input.split(" ");
            long firstNumber = Long.parseLong(inputData[0]);
            int amountOfNumber = Integer.parseInt(inputData[1]);
            ArrayList<String> arrayOfProperties = new ArrayList<>(Arrays.asList(Arrays.copyOfRange(inputData, 2, inputData.length)));

            SeveralNumbers severalNumbers = new SeveralNumbers(String.valueOf(firstNumber));
            ArrayList<SeveralNumbers> arrayListOfNumber = new ArrayList<>(amountOfNumber);
            while (arrayListOfNumber.size() < amountOfNumber) {
                if (correspondsToProperties(severalNumbers, arrayOfProperties)) {
                    arrayListOfNumber.add(severalNumbers);
                }
                severalNumbers = new SeveralNumbers(String.valueOf(++firstNumber));
            }
            return arrayListOfNumber;
        }

        public static boolean correspondsToProperties(SeveralNumbers severalNumbers, ArrayList<String> properties) {
            boolean isCorresponds = false;
            for (String s :
                    properties) {
                if (!severalNumbers.toString().contains(s.toLowerCase())) {
                    isCorresponds = false;
                    break;
                } else {
                    isCorresponds = true;
                }
            }
            return isCorresponds;
        }

        @Override
        public String toString() {
            return value
                    + " is "
                    + (isBuzz ? "buzz, " : "")
                    + (isDuck ? "duck, " : "")
                    + (isPalindromic ? "palindromic, " : "")
                    + (isGapful ? "gapful, " : "")
                    + (isSpy ? "spy, " : "")
                    + (isSquare ? "square, " : "")
                    + (isSunny ? "sunny, " : "")
                    + (isJumping ? "jumping, " : "")
                    + (isEven ? "even" : "")
                    + (!isEven ? "odd" : "");
        }
    }
  learner_created: true
- name: src/numbers/Properties.java
  visible: true
  text: |
    package numbers;

    enum Properties {
        EVEN("EVEN"),
        ODD("ODD"),
        BUZZ("BUZZ"),
        DUCK("DUCK"),
        PALINDROMIC("PALINDROMIC"),
        GAPFUL("GAPFUL"),
        SPY("SPY"),
        SQUARE("SQUARE"),
        SUNNY("SUNNY"),
        JUMPING("JUMPING");

        private String name;

        Properties(String name) {
            this.name = name;
        }

        public String getName() {
            return name;
        }
    }
  learner_created: true
feedback_link: https://hyperskill.org/projects/184/stages/938/implement#comment
status: Solved
feedback:
  message: Well done! You've finished the project. Select a new project on <a href="https://hyperskill.org/projects">JetBrains
    Academy</a> to continue learning.
  time: Fri, 17 Sep 2021 19:54:00 UTC
record: 8
